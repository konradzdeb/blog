---
title: On Sorting Arrays...or why it's good to read the actual assignment
author: Konrad Zdeb
date: '2021-05-23'
slug: fun-with-sortting-arrays
categories:
  - fun
tags:
  - python
---

# Problem 

Solving challenges on [project Euler](https://projecteuler.net)  or [HackerRank](https://www.hackerrank.com/) is a good past time. For folks working in the wider analaytical / data science field, places like project Euler provide an excellent opportunity to work with academic programming concepts that do not frequently appear in real-life. I was looking at common problem:

> You are given an unordered array consisting of consecutive integers  [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. Find the minimum number of swaps required to sort the array in ascending order.  
Example
Perform the following steps:  
```
i   arr                     swap (indices)
0   [7, 1, 3, 2, 4, 5, 6]   swap (0,3)  
1   [2, 1, 3, 7, 4, 5, 6]   swap (0,1)  
2   [1, 2, 3, 7, 4, 5, 6]   swap (3,4)  
3   [1, 2, 3, 4, 7, 5, 6]   swap (4,5)  
4   [1, 2, 3, 4, 5, 7, 6]   swap (5,6)  
5   [1, 2, 3, 4, 5, 6, 7]  
```
*It took  swaps to sort the array.*

# Solution

## First attempt

After completing the problem, I like to explore literature and search or post on [CodeReview](https://codereview.stackexchange.com) for feedback. My initial solution simply involved re-starting array sort and counting each approach. As arrays are consisting of unordered consecutive integers âˆˆ [1, 2, 3, ..., n], the easiest solution 

```{python initial_approach, echo=TRUE}
def minimumSwaps(arr):
    # Add zero to avoid the need of shifting the index so all the loops
    # are working fine
    arr.insert(0, 0)
    num_sorts = 0
    while arr != sorted(arr):
        for idx, val in enumerate(arr):
            if idx != val:
                arr[idx], arr[val] = arr[val], arr[idx]
                num_sorts += 1
                break
    return num_sorts
```

The solution returns the correct results but times out for 6 cases that consists of bigger arrays.

**Passed tests: 8 / 14**

## Second attempt 

My first thought was to quickly optimise the existing code by looking for quick wins. The sorting operation in `while arr != sorted(arr)` could be optimised by storing sorted object (as each array has only one sorted order that meets the criteria). 

```{python second_solution, echo=TRUE}
def minimumSwaps(arr):
    # Add zero to avoid the need of shifting the index so all the loops
    # are working fine
    arr.insert(0, 0)
    num_sorts = 0
    array_sorted = sorted(arr) # First optimisation
    while arr != array_sorted:
        for idx, val in enumerate(arr):
            if idx != val:
                arr[idx], arr[val] = arr[val], arr[idx]
                num_sorts += 1
                break
    return num_sorts
```

The line `array_sorted = sorted(arr)` makes the solution time out only once.

**Passed tests: 13/14**



## Assessment

# Conclusions
I don't remember where I've seen this statement but someone once said:

> RAM is cheap, thinking is expensive

There are some principles that this solution breaks. 

* **First** a good program computes what is has to and only that. The task is to return *the numbers of steps* not to *sort.* Sorting implies actual movement of elements in array and potentially will have a different (likely worse) memory footprint to a purely algebraic solution.
* **Second,** a premature optimisation is frequent source of bugs.

